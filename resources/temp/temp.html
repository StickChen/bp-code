<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<div class="RichContent-inner"><span class="RichText ztext CopyrightRichText-richText" itemprop="text"><p>优势很明显，就是同等一个单位的协程，比一个单位线程要节省太多内存</p><p>但是等到java的loom做出来，优劣势会马上逆转，这个其实在kotlin上已经表现得很明显了</p><p>在kotlin上我们可以自由地在线程和协程之间切换，而go只有协程，无法自由地在线程和协程之间切换，酱紫对于造轮子很不利</p><p>现在haskell也在抄袭kotlin的做法，eta打算实现haskell在jvm上的协程/fiber，将来export到vert.x上去，而java自身也在制作loom，也就是java版的协程，以及zgc，也就是java版的10ms以内的gc</p><hr><p>好评论区看来有人不太懂我后面说的哈，那我们用一个通俗的模型来解释一下</p><p>假设你的cpu只有一个core</p><p>然后考虑以下三种情况</p><ol><li>只跑一个线程，该线程顺序执行每个任务</li><li>跑n个线程，每个任务分配一个线程执行</li><li>跑n个协程/绿色线程 等，这玩意有好多名字，每个任务跑一个协程</li></ol><p>好，请问，总时间最短是哪个？</p><p>答案是第一个，因为第一个没有任何浪费，os不需要分配资源给线程或者协程的调度</p><p>这可以理解吧？其次是第三个，全协程的方式，最差是全线程，因为每一个线程所消耗的资源，都比协程要多</p><p>但是客户体验呢？如果不做任何的优化，2和3在资源足够的前提下，体验都是好的</p><p>1如果不做处理，会有严重的客户体验的问题，假设100个任务，其中第一个任务耗时30s</p><p>其他任务耗时0.1s，那如果是1的情况，所有任务都需要等待30s以后方能给出答案</p><p>2和3除了第一个任务，其他任务几乎会马上返回结果</p><p>但是呢，总的任务执行时间，还是1最短，因为没有任何调度的消耗</p><p>这也能理解吧？</p><p>那这就有一个矛盾，客户体验和总的执行时间之间的矛盾，如果2和3的话，虽然客户体验好了，但是总的执行时间还是不足，反过来，1的总执行时间短，但是因为顺序执行，导致其他任务被blocked住了，所以客户体验并不好，这就是一个两难了</p><p>其实2和3还有一个问题，就是并发操作的问题，而要对付并发，会带来开发难度的上升，要么immutable要么lock，都很麻烦，lock更麻烦一点，所以2和3在数量上去之后，一旦并发操作需求提出来，这里会导致开发成本成倍上升，处理不好的话，性能也是直线下降，死锁之类的很麻烦的</p><p>而反观1，因为它是纯粹的单线程环境，所以它没有这个问题，只是客户体验一般般而已啦，那肿么办呢？1提出一个non blocking的概念，就是当需要的时候，我们再启动其他线程予以处理，那什么时候需要？就需要框架自行判断了，要么用户自己做，要么框架实现，框架实现就是提供一种non blocking api来将结果在一定时间后返回，并塞回原来线程中继续执行，这就是著名的callback问题</p><p>看到这里，你应该能够猜出来了吧？</p><p>1是node，2是spring，3是go</p><p>显然1的方式是最有效率的，唯一的问题就是需要去考虑block与否的问题，不那么容易做，但是这是right way to go</p><p>然后把1扩展到多个cores，这就是node.x，也就是vert.x之前的名字</p><p>注意一下，这种模式效率是最高的，但是会带来开发的问题</p><p>那就是前面说的著名的callback，那怎么办？</p><p>一种方式，fp的方式，monad也就是future，或者是高阶函数，比如map, reduce, filter etc.，这种方式呢，不错，挺好，但是monad没有那么容易理解，高阶函数也不太容易理解，学习成本在这里，后者就是vert.x上的reactivex的方式，rxjava，rxjs etc.，我相信pure fp的用户，e.g. haskell，lisp/clojure会更喜欢这种方式</p><p>还有一种方式呢？看到上面的协程了没有？用协程来改造callback，协程可以暂停，你想想啊，如果只有一个core，多个协程，那是怎么实现的？所以这个时候，我们会把non blocking的api改造，做成suspend api，简而言之，就是一种能够将当前线程释放，并允许线程不停滴check是否已经获取callback结果的api，那在使用callback的时候，先启动一个协程，然后调用suspend api，当然，这会带来调度，但是我们是在需要的时候，才启动协程，而不是一上来就启动协程，所以这带来的调度的消耗，会远小于3那种情形下的消耗，这个消耗，大概是3%-5%左右，基本上可以接受，这个在vert.x上就是kotlin的coroutine实现，我们可以认为这是oop的方式，因为代码写起来基本上与传统的oop无异，除了加多一个启动协程的过程，换而言之，这是当我们需要才启动协程的模式，我相信，传统java开发人员，会更倾向这种方式</p><p>所以将来的走向是这两种之一：reactivex vs coroutine</p><p>具体是哪一种，嗯，不得而知了，做到两种都兼容就对了</p><hr><p>估计很多人关心效率，为什么vert.x能够超越go，go管得太多了，控制不了的时候，就力不从心了</p><p>嗯，关于coroutine在vert.x上的使用，以及通过subset of code跑在coroutine上，从而实现better performance的效果，可以参考kotlin的某个攻城狮的发言，这一段基本上说明了我们在vert.x上是如何使用coroutine的：</p><blockquote>Go runtime takes complete control of scheduling goroutines execution on the physical OS threads. The advantage of this approach is that you don't have to think about it all. With Kotlin coroutines you have fine-grained control on the execution environment of your coroutines. This is error-prone (e.g. you may simply create too many different thread-pools and waste your CPU time on context switching between them). However, it gives you ability to fine-tune your thread allocation and context switches for your application. For example, in Kotlin it is easy to execute your whole application or a subset of its code in a single OS thread (or thread pool) to completely avoid switching contexts between OS threads just by writing an appropriate code for that.</blockquote><p><a href="https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/46864623/which-of-coroutines-goroutines-and-kotlin-coroutines-are-faster" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">Which of coroutines (goroutines and kotlin coroutines) are faster?</a></p><p>作者的linkedin：<a href="https://link.zhihu.com/?target=https%3A//ru.linkedin.com/in/relizarov" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">Roman Elizarov</a> </p><p>值得注意的是，将来通过高阶函数以及monad(vert.x的future)能够实现比coroutine更加卓越的表现，注意前面说的，coroutine会有3%-5%的消耗，而pure callback则没有这种问题，只是用coroutine会更加便于我们无脑填代码，所以我个人还是比较看好haskell在vert.x上的前景的，虽然kotlin已经让事情变得如此简单了，但是追求高性能的脚步永不停歇</p></span></div>
</body>
</html>